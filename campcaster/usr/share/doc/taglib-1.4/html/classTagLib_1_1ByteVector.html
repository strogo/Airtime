<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>TagLib: TagLib::ByteVector Class Reference (TagLib)</title>
    <link href="taglib-api.css" rel="stylesheet" type="text/css">
  </head>
  <body>

    
    <div id="container">

      <table border="0" width="100%">
          <tr>
            <td width="1">
              <img src="../taglib.png">
            </td>
            <td>
              <div id="intro">
                <table border="0" height="119" cellpadding="0" cellspacing="0" width="100%">
                    <tr><td valign="top"><h1>TagLib 1.4 (TagLib: TagLib::ByteVector Class Reference)</h1></td></tr>
                    <tr>
                      <td valign="bottom">
                        <div id="links">
                          <a href="index.html">Home</a>
                          <a href="inherits.html">Class&nbsp;Hierarchy</a>
                          <a href="namespaces.html">Namespaces</a>
                          <a href="annotated.html">Classes</a>
                          <a href="files.html">Headers</a>
                          <a href="namespacemembers.html">Namespace&nbsp;Members</a>
                          <a href="functions.html">Class&nbsp;Members</a>
                          <a href="globals.html">File&nbsp;Members</a>
                        </div>
                      </td>
                    </tr>
                </table>
              </div>
            </td>
          </tr>
      </table>

      <div id="text">
<!-- Generated by Doxygen 1.5.3 -->
<div class="nav">
<a class="el" href="namespaceTagLib.html">TagLib</a>::<a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a></div>
<h1>TagLib::ByteVector Class Reference</h1><!-- doxytag: class="TagLib::ByteVector" -->A byte vector.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="tbytevector_8h-source.html">tbytevector.h</a>&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for TagLib::ByteVector:</div>
<div class="dynsection">
<p><center><img src="classTagLib_1_1ByteVector__coll__graph.png" border="0" usemap="#TagLib_1_1ByteVector__coll__map" alt="Collaboration graph"></center>
<map name="TagLib_1_1ByteVector__coll__map">
<area shape="rect" title="null" alt="" coords="141,7,149,15"><area shape="rect" title="null" alt="" coords="141,25,149,33"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classTagLib_1_1ByteVector-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#f6e5b2614dacfc049b5b6e32063d4aa1">ByteVector</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#6e3bb27e43b76a1e3e40c8364ad7158c">ByteVector</a> (<a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> size, char value=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#613e5467e1b582775f98eed1e2f6c1ef">ByteVector</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a286e2ae6447e55e85ef855838d10c96">ByteVector</a> (char c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#d3fee04984a628e55cf480d56604e9ce">ByteVector</a> (const char *data, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3cd4cd25e6b8fbd6a795005478b08e0">ByteVector</a> (const char *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#34b45e9a86728313ddef12a037acc73d">~ByteVector</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#49cb0f6594227c97895b69be16433ce9">setData</a> (const char *data, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#99dee016824c3020d1b4753028645dc8">setData</a> (const char *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#55d40ed1e9b9749e3895c845f1f26901">data</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ffe39991f59ce978639ef48400b0891b">data</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#b347f103e6c2bba92fdf491031dc46ba">mid</a> (<a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> index, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length=0xffffffff) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#4db625889dc6281783ae25d3733e0919">at</a> (<a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#557c662441974ba731bfdf9a360df5ce">find</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> offset=0, int byteAlign=1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#46c984d49bda6a270f62d98b6a2933e4">rfind</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> offset=0, int byteAlign=1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#b62281faaa15a69073f4b830ad576213">containsAt</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> offset, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> patternOffset=0, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> patternLength=0xffffffff) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#5f330306a73bbd23d89f7c14a2126456">startsWith</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#68505e709c3cc3061ca0de7a04251f46">endsWith</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#fe9d03a684dbba770e2871a2dfe1d55a">endsWithPartialMatch</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#622a469f255e36bf2ccb9463b032dd08">append</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ebfff849447f1a78eb8de8bb1848e31f">clear</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#d35dc30632085e7696660de9694bbc24">size</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#dd7490c1075ad2e119a164fb5491fd44">resize</a> (<a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> size, char padding=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#99848a9fbcb7b39e16866a881e2b115f">begin</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab4c8b26244d1efc6f392062a3146e41">begin</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#53a1f28d1a51f7351733f2ef22090c34">end</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#cc7a47ae21af8e3a02be6346c078f2b8">end</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#3ab3712f32591b5af95f3fe43421f704">isNull</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#bf4db491627843669c3d26263f18ef72">isEmpty</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#e497a9e2f33d7e7cd78558a6991db707">checksum</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#1f234fafaa7cb0f13c85a7aed996e4a4">toUInt</a> (bool mostSignificantByteFirst=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#792be96ea5c9edb1d1eb9e987d0f0b1d">toShort</a> (bool mostSignificantByteFirst=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#398ca4acfe99175547dd239a2ed83730">toLongLong</a> (bool mostSignificantByteFirst=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#2ec096b29dc0f9222ca393692fae128a">operator[]</a> (int index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#6c078f5864c875eb49a0e900336191e2">operator[]</a> (int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#9e891841a6c5259b177498a19a91c758">operator==</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#3918f3327686bc80a6022bf66fb86124">operator!=</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#0ae63d46b0a9ddd6971c40502cb7835f">operator==</a> (const char *s) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#0167694c169d832fa0b1012a5d62d89c">operator!=</a> (const char *s) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#264ff435cb7f79bd93ccdb1ba4d5c52f">operator&lt;</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#5c3f661ccc7cf8309089e9b3a284d3bc">operator&gt;</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#5de1892f12726bb4d50276abd8f64edc">operator+</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#c612d7f38571456c5f0083e07df554cd">operator=</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#4a8204c1556dee0a7f330962b8587381">operator=</a> (char c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ba5947f410bee90e1cd36a0dd931113d">operator=</a> (const char *data)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#680335d571501172e98df012aae52335">fromUInt</a> (<a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> value, bool mostSignificantByteFirst=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#162543bf4b280468a677799686178522">fromShort</a> (short value, bool mostSignificantByteFirst=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#51b81a576453f38fb816294f1e77a76d">fromLongLong</a> (long long value, bool mostSignificantByteFirst=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#2782f08a6b8350c4e5f17548a60b5495">fromCString</a> (const char *s, <a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> length=0xffffffff)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#7593a608427eb6f855c4dc48558ad8a4">null</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ed0573f25ee917a40d6cd242b3115ae0">detach</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#74ae5e40be3b59fc2989711a0855a19c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;v)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A byte vector. 
<p>
This class provides a byte vector with some methods that are useful for tagging purposes. Many of the search functions are tailored to what is useful for finding tag related paterns in a data array. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="f6e5b2614dacfc049b5b6e32063d4aa1"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="f6e5b2614dacfc049b5b6e32063d4aa1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an empty byte vector. 
</div>
</div><p>
<a class="anchor" name="6e3bb27e43b76a1e3e40c8364ad7158c"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="6e3bb27e43b76a1e3e40c8364ad7158c" args="(uint size, char value=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a vector of size <em>size</em> with all values set to <em>value</em> by default. 
</div>
</div><p>
<a class="anchor" name="613e5467e1b582775f98eed1e2f6c1ef"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="613e5467e1b582775f98eed1e2f6c1ef" args="(const ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contructs a byte vector that is a copy of <em>v</em>. 
</div>
</div><p>
<a class="anchor" name="a286e2ae6447e55e85ef855838d10c96"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="a286e2ae6447e55e85ef855838d10c96" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contructs a byte vector that contains <em>c</em>. 
</div>
</div><p>
<a class="anchor" name="d3fee04984a628e55cf480d56604e9ce"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="d3fee04984a628e55cf480d56604e9ce" args="(const char *data, uint length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a byte vector that copies <em>data</em> for up to <em>length</em> bytes. 
</div>
</div><p>
<a class="anchor" name="a3cd4cd25e6b8fbd6a795005478b08e0"></a><!-- doxytag: member="TagLib::ByteVector::ByteVector" ref="a3cd4cd25e6b8fbd6a795005478b08e0" args="(const char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a byte vector that copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. This is particularly useful for constructing byte arrays from string constants. 
</div>
</div><p>
<a class="anchor" name="34b45e9a86728313ddef12a037acc73d"></a><!-- doxytag: member="TagLib::ByteVector::~ByteVector" ref="34b45e9a86728313ddef12a037acc73d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual TagLib::ByteVector::~ByteVector           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> instance. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="49cb0f6594227c97895b69be16433ce9"></a><!-- doxytag: member="TagLib::ByteVector::setData" ref="49cb0f6594227c97895b69be16433ce9" args="(const char *data, uint length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::setData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the data for the byte array using the first <em>length</em> bytes of <em>data</em> 
</div>
</div><p>
<a class="anchor" name="99dee016824c3020d1b4753028645dc8"></a><!-- doxytag: member="TagLib::ByteVector::setData" ref="99dee016824c3020d1b4753028645dc8" args="(const char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::setData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the data for the byte array copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. 
</div>
</div><p>
<a class="anchor" name="55d40ed1e9b9749e3895c845f1f26901"></a><!-- doxytag: member="TagLib::ByteVector::data" ref="55d40ed1e9b9749e3895c845f1f26901" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TagLib::ByteVector::data           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the internal data structure.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Care should be taken when modifying this data structure as it is easy to corrupt the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> when doing so. Specifically, while the data may be changed, its length may not be. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffe39991f59ce978639ef48400b0891b"></a><!-- doxytag: member="TagLib::ByteVector::data" ref="ffe39991f59ce978639ef48400b0891b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TagLib::ByteVector::data           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the internal data structure which may not be modified. 
</div>
</div><p>
<a class="anchor" name="b347f103e6c2bba92fdf491031dc46ba"></a><!-- doxytag: member="TagLib::ByteVector::mid" ref="b347f103e6c2bba92fdf491031dc46ba" args="(uint index, uint length=0xffffffff) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::mid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>0xffffffff</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a byte vector made up of the bytes starting at <em>index</em> and for <em>length</em> bytes. If <em>length</em> is not specified it will return the bytes from <em>index</em> to the end of the vector. 
</div>
</div><p>
<a class="anchor" name="4db625889dc6281783ae25d3733e0919"></a><!-- doxytag: member="TagLib::ByteVector::at" ref="4db625889dc6281783ae25d3733e0919" args="(uint index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char TagLib::ByteVector::at           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This essentially performs the same as <a class="el" href="classTagLib_1_1ByteVector.html#2ec096b29dc0f9222ca393692fae128a">operator[]()</a>, but instead of causing a runtime error if the index is out of bounds, it will return a null byte. 
</div>
</div><p>
<a class="anchor" name="557c662441974ba731bfdf9a360df5ce"></a><!-- doxytag: member="TagLib::ByteVector::find" ref="557c662441974ba731bfdf9a360df5ce" args="(const ByteVector &amp;pattern, uint offset=0, int byteAlign=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byteAlign</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> for <em>pattern</em> starting at <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byteDivisible by <em>byteAlign</em>. 
</div>
</div><p>
<a class="anchor" name="46c984d49bda6a270f62d98b6a2933e4"></a><!-- doxytag: member="TagLib::ByteVector::rfind" ref="46c984d49bda6a270f62d98b6a2933e4" args="(const ByteVector &amp;pattern, uint offset=0, int byteAlign=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::rfind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byteAlign</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> for <em>pattern</em> starting from either the end of the vector or <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byteDivisible by <em>byteAlign</em>. 
</div>
</div><p>
<a class="anchor" name="b62281faaa15a69073f4b830ad576213"></a><!-- doxytag: member="TagLib::ByteVector::containsAt" ref="b62281faaa15a69073f4b830ad576213" args="(const ByteVector &amp;pattern, uint offset, uint patternOffset=0, uint patternLength=0xffffffff) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::containsAt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>patternOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>patternLength</em> = <code>0xffffffff</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see if the vector contains the <em>pattern</em> starting at position <em>offset</em>. Optionally, if you only want to search for part of the pattern you can specify an offset within the pattern to start from. Also, you can specify to only check for the first <em>patternLength</em> bytes of <em>pattern</em> with the <em>patternLength</em> argument. 
</div>
</div><p>
<a class="anchor" name="5f330306a73bbd23d89f7c14a2126456"></a><!-- doxytag: member="TagLib::ByteVector::startsWith" ref="5f330306a73bbd23d89f7c14a2126456" args="(const ByteVector &amp;pattern) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::startsWith           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the vector starts with <em>pattern</em>. 
</div>
</div><p>
<a class="anchor" name="68505e709c3cc3061ca0de7a04251f46"></a><!-- doxytag: member="TagLib::ByteVector::endsWith" ref="68505e709c3cc3061ca0de7a04251f46" args="(const ByteVector &amp;pattern) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::endsWith           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the vector ends with <em>pattern</em>. 
</div>
</div><p>
<a class="anchor" name="fe9d03a684dbba770e2871a2dfe1d55a"></a><!-- doxytag: member="TagLib::ByteVector::endsWithPartialMatch" ref="fe9d03a684dbba770e2871a2dfe1d55a" args="(const ByteVector &amp;pattern) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::endsWithPartialMatch           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pattern</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for a partial match of <em>pattern</em> at the end of the vector. It returns the offset of the partial match within the vector, or -1 if the pattern is not found. This method is particularly useful when searching for patterns that start in one vector and end in another. When combined with <a class="el" href="classTagLib_1_1ByteVector.html#5f330306a73bbd23d89f7c14a2126456">startsWith()</a> it can be used to find a pattern that overlaps two buffers.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This will not match the complete pattern at the end of the string; use <a class="el" href="classTagLib_1_1ByteVector.html#68505e709c3cc3061ca0de7a04251f46">endsWith()</a> for that. </dd></dl>

</div>
</div><p>
<a class="anchor" name="622a469f255e36bf2ccb9463b032dd08"></a><!-- doxytag: member="TagLib::ByteVector::append" ref="622a469f255e36bf2ccb9463b032dd08" args="(const ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::append           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends <em>v</em> to the end of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. 
</div>
</div><p>
<a class="anchor" name="ebfff849447f1a78eb8de8bb1848e31f"></a><!-- doxytag: member="TagLib::ByteVector::clear" ref="ebfff849447f1a78eb8de8bb1848e31f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the data. 
</div>
</div><p>
<a class="anchor" name="d35dc30632085e7696660de9694bbc24"></a><!-- doxytag: member="TagLib::ByteVector::size" ref="d35dc30632085e7696660de9694bbc24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> TagLib::ByteVector::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the size of the array. 
</div>
</div><p>
<a class="anchor" name="dd7490c1075ad2e119a164fb5491fd44"></a><!-- doxytag: member="TagLib::ByteVector::resize" ref="dd7490c1075ad2e119a164fb5491fd44" args="(uint size, char padding=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::resize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>padding</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize the vector to <em>size</em>. If the vector is currently less than <em>size</em>, pad the remaining spaces with <em>padding</em>. Returns a reference to the resized vector. 
</div>
</div><p>
<a class="anchor" name="99848a9fbcb7b39e16866a881e2b115f"></a><!-- doxytag: member="TagLib::ByteVector::begin" ref="99848a9fbcb7b39e16866a881e2b115f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an Iterator that points to the front of the vector. 
</div>
</div><p>
<a class="anchor" name="ab4c8b26244d1efc6f392062a3146e41"></a><!-- doxytag: member="TagLib::ByteVector::begin" ref="ab4c8b26244d1efc6f392062a3146e41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a ConstIterator that points to the front of the vector. 
</div>
</div><p>
<a class="anchor" name="53a1f28d1a51f7351733f2ef22090c34"></a><!-- doxytag: member="TagLib::ByteVector::end" ref="53a1f28d1a51f7351733f2ef22090c34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an Iterator that points to the back of the vector. 
</div>
</div><p>
<a class="anchor" name="cc7a47ae21af8e3a02be6346c078f2b8"></a><!-- doxytag: member="TagLib::ByteVector::end" ref="cc7a47ae21af8e3a02be6346c078f2b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a ConstIterator that points to the back of the vector. 
</div>
</div><p>
<a class="anchor" name="3ab3712f32591b5af95f3fe43421f704"></a><!-- doxytag: member="TagLib::ByteVector::isNull" ref="3ab3712f32591b5af95f3fe43421f704" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isNull           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the vector is null.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A vector may be empty without being null. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#bf4db491627843669c3d26263f18ef72">isEmpty()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf4db491627843669c3d26263f18ef72"></a><!-- doxytag: member="TagLib::ByteVector::isEmpty" ref="bf4db491627843669c3d26263f18ef72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isEmpty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is empty.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#d35dc30632085e7696660de9694bbc24">size()</a> <p>
<a class="el" href="classTagLib_1_1ByteVector.html#3ab3712f32591b5af95f3fe43421f704">isNull()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e497a9e2f33d7e7cd78558a6991db707"></a><!-- doxytag: member="TagLib::ByteVector::checksum" ref="e497a9e2f33d7e7cd78558a6991db707" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> TagLib::ByteVector::checksum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a CRC checksum of the byte vector's data. 
</div>
</div><p>
<a class="anchor" name="1f234fafaa7cb0f13c85a7aed996e4a4"></a><!-- doxytag: member="TagLib::ByteVector::toUInt" ref="1f234fafaa7cb0f13c85a7aed996e4a4" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a> TagLib::ByteVector::toUInt           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificantByteFirst</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the first 4 bytes of the vector to an unsigned integer.<p>
If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="792be96ea5c9edb1d1eb9e987d0f0b1d"></a><!-- doxytag: member="TagLib::ByteVector::toShort" ref="792be96ea5c9edb1d1eb9e987d0f0b1d" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TagLib::ByteVector::toShort           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificantByteFirst</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the first 2 bytes of the vector to a short.<p>
If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="398ca4acfe99175547dd239a2ed83730"></a><!-- doxytag: member="TagLib::ByteVector::toLongLong" ref="398ca4acfe99175547dd239a2ed83730" args="(bool mostSignificantByteFirst=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long TagLib::ByteVector::toLongLong           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificantByteFirst</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the first 8 bytes of the vector to a (signed) long long.<p>
If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#680335d571501172e98df012aae52335">fromUInt()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="680335d571501172e98df012aae52335"></a><!-- doxytag: member="TagLib::ByteVector::fromUInt" ref="680335d571501172e98df012aae52335" args="(uint value, bool mostSignificantByteFirst=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromUInt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificantByteFirst</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#1f234fafaa7cb0f13c85a7aed996e4a4">toUInt()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="162543bf4b280468a677799686178522"></a><!-- doxytag: member="TagLib::ByteVector::fromShort" ref="162543bf4b280468a677799686178522" args="(short value, bool mostSignificantByteFirst=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromShort           </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificantByteFirst</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a 2 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 01 == 0x0001 == 1, if false, $01 00 == 0x0100 == 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#792be96ea5c9edb1d1eb9e987d0f0b1d">toShort()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="51b81a576453f38fb816294f1e77a76d"></a><!-- doxytag: member="TagLib::ByteVector::fromLongLong" ref="51b81a576453f38fb816294f1e77a76d" args="(long long value, bool mostSignificantByteFirst=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromLongLong           </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mostSignificantByteFirst</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#398ca4acfe99175547dd239a2ed83730">toLongLong()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2782f08a6b8350c4e5f17548a60b5495"></a><!-- doxytag: member="TagLib::ByteVector::fromCString" ref="2782f08a6b8350c4e5f17548a60b5495" args="(const char *s, uint length=0xffffffff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromCString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceTagLib.html#0d56da3fb97ff5e823c2c4b3aea77e25">uint</a>&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>0xffffffff</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on the CString <em>s</em>. 
</div>
</div><p>
<a class="anchor" name="2ec096b29dc0f9222ca393692fae128a"></a><!-- doxytag: member="TagLib::ByteVector::operator[]" ref="2ec096b29dc0f9222ca393692fae128a" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char&amp; TagLib::ByteVector::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a const refernence to the byte at <em>index</em>. 
</div>
</div><p>
<a class="anchor" name="6c078f5864c875eb49a0e900336191e2"></a><!-- doxytag: member="TagLib::ByteVector::operator[]" ref="6c078f5864c875eb49a0e900336191e2" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; TagLib::ByteVector::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a reference to the byte at <em>index</em>. 
</div>
</div><p>
<a class="anchor" name="9e891841a6c5259b177498a19a91c758"></a><!-- doxytag: member="TagLib::ByteVector::operator==" ref="9e891841a6c5259b177498a19a91c758" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and <em>v</em> are equal. 
</div>
</div><p>
<a class="anchor" name="3918f3327686bc80a6022bf66fb86124"></a><!-- doxytag: member="TagLib::ByteVector::operator!=" ref="3918f3327686bc80a6022bf66fb86124" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and <em>v</em> are not equal. 
</div>
</div><p>
<a class="anchor" name="0ae63d46b0a9ddd6971c40502cb7835f"></a><!-- doxytag: member="TagLib::ByteVector::operator==" ref="0ae63d46b0a9ddd6971c40502cb7835f" args="(const char *s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator==           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and the null terminated C string <em>s</em> contain the same data. 
</div>
</div><p>
<a class="anchor" name="0167694c169d832fa0b1012a5d62d89c"></a><!-- doxytag: member="TagLib::ByteVector::operator!=" ref="0167694c169d832fa0b1012a5d62d89c" args="(const char *s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and the null terminated C string <em>s</em> do not contain the same data. 
</div>
</div><p>
<a class="anchor" name="264ff435cb7f79bd93ccdb1ba4d5c52f"></a><!-- doxytag: member="TagLib::ByteVector::operator&lt;" ref="264ff435cb7f79bd93ccdb1ba4d5c52f" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is less than <em>v</em>. The value of the vectors is determined by evaluating the character from left to right, and in the event one vector is a superset of the other, the size is used. 
</div>
</div><p>
<a class="anchor" name="5c3f661ccc7cf8309089e9b3a284d3bc"></a><!-- doxytag: member="TagLib::ByteVector::operator&gt;" ref="5c3f661ccc7cf8309089e9b3a284d3bc" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is greater than <em>v</em>. 
</div>
</div><p>
<a class="anchor" name="5de1892f12726bb4d50276abd8f64edc"></a><!-- doxytag: member="TagLib::ByteVector::operator+" ref="5de1892f12726bb4d50276abd8f64edc" args="(const ByteVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::operator+           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a vector that is <em>v</em> appended to this vector. 
</div>
</div><p>
<a class="anchor" name="c612d7f38571456c5f0083e07df554cd"></a><!-- doxytag: member="TagLib::ByteVector::operator=" ref="c612d7f38571456c5f0083e07df554cd" args="(const ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. 
</div>
</div><p>
<a class="anchor" name="4a8204c1556dee0a7f330962b8587381"></a><!-- doxytag: member="TagLib::ByteVector::operator=" ref="4a8204c1556dee0a7f330962b8587381" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator=           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. 
</div>
</div><p>
<a class="anchor" name="ba5947f410bee90e1cd36a0dd931113d"></a><!-- doxytag: member="TagLib::ByteVector::operator=" ref="ba5947f410bee90e1cd36a0dd931113d" args="(const char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator=           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. 
</div>
</div><p>
<a class="anchor" name="ed0573f25ee917a40d6cd242b3115ae0"></a><!-- doxytag: member="TagLib::ByteVector::detach" ref="ed0573f25ee917a40d6cd242b3115ae0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::detach           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="74ae5e40be3b59fc2989711a0855a19c"></a><!-- doxytag: member="TagLib::ByteVector::operator&lt;&lt;" ref="74ae5e40be3b59fc2989711a0855a19c" args="(std::ostream &amp;s, const TagLib::ByteVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Streams the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em> to the output stream <em>s</em>. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="7593a608427eb6f855c4dc48558ad8a4"></a><!-- doxytag: member="TagLib::ByteVector::null" ref="7593a608427eb6f855c4dc48558ad8a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> <a class="el" href="classTagLib_1_1ByteVector.html#7593a608427eb6f855c4dc48558ad8a4">TagLib::ByteVector::null</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A static, empty <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> which is convenient and fast (since returning an empty or "null" value does not require instantiating a new <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>). 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tbytevector_8h-source.html">tbytevector.h</a></ul>
      </div>
    </div>
  </body>
</html>
